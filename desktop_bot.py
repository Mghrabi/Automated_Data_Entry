#!/usr/bin/env python3
"""
TJM Desktop Data Entry Bot - Uses Desktop Applications
Automates data entry in TextEdit (macOS) or Notepad (Windows)
macOS: Tested successfully
Windows: Not tested
"""

import time
import requests
import pyautogui
import subprocess
import platform
from pathlib import Path

class DesktopDataEntryBot:
    def __init__(self):
        # Configure PyAutoGUI for reliable automation
        pyautogui.PAUSE = 0.1  # Very fast pause for speed
        pyautogui.FAILSAFE = True  # Move mouse to top-left corner to stop
        
        # Detect operating system for platform-specific behavior
        self.os_type = platform.system()
        print(f"ğŸ–¥ï¸  Detected OS: {self.os_type}")
        
        # Create project directory on desktop for saving files
        self.desktop_path = Path.home() / "Desktop"
        self.project_dir = self.desktop_path / "tjm-project"
        
        # Ensure the tjm-project directory exists
        if not self.project_dir.exists():
            print(f"ğŸ“ Creating project directory: {self.project_dir}")
            self.project_dir.mkdir(parents=True, exist_ok=True)
        else:
            print(f"ğŸ“ Project directory exists: {self.project_dir}")
    
    def fetch_posts(self, limit=10):
        """Fetch blog posts from JSONPlaceholder API with error handling"""
        try:
            # API endpoint for fetching posts with limit
            url = f"https://jsonplaceholder.typicode.com/posts?_limit={limit}"
            response = requests.get(url, timeout=10)  # 10 second timeout
            response.raise_for_status()  # Raise exception for bad status codes
            return response.json()  # Return JSON data
        except requests.RequestException as e:
            print(f"âŒ Error fetching posts: {e}")
            return []
    
    def format_post_content(self, post):
        """Format API post data as a structured blog post"""
        # Capitalize title for better presentation
        title = post['title'].title()
        # Replace single newlines with double newlines for better paragraph spacing
        body = post['body'].replace('\n', '\n\n')
        
        # Create formatted blog post content
        content = f"""BLOG POST #{post['id']}


TITLE: {title}

CONTENT:
{body}

---
Post ID: {post['id']}
User ID: {post['userId']}
Generated by TJM Automation Bot
Platform: {self.os_type}
Date: {time.strftime('%Y-%m-%d %H:%M:%S')}
"""
        return content
    
    def launch_text_editor(self):
        """Launch appropriate text editor based on operating system"""
        try:
            if self.os_type == "Darwin":  # macOS
                # Launch TextEdit application
                subprocess.Popen(['open', '-a', 'TextEdit'])
                time.sleep(3)  # Wait for TextEdit to launch
                
                # Create new document using Cmd+N shortcut with .hold()
                with pyautogui.hold(['command']):
                    time.sleep(0.1)
                    pyautogui.press('n')
                time.sleep(2)
                
                # Ensure TextEdit is in plain text mode for better compatibility
                with pyautogui.hold(['command']):
                    time.sleep(0.1)
                    pyautogui.press('shift')
                    pyautogui.press('t')
                time.sleep(1)
                return True
                
            elif self.os_type == "Windows":  # Windows
                # Launch Notepad on Windows
                subprocess.Popen(['notepad.exe'])
                time.sleep(2)
                return True
                
            elif self.os_type == "Linux":  # Linux
                # Try common Linux text editors in order of preference
                editors = ['gedit', 'kate', 'mousepad', 'leafpad']
                for editor in editors:
                    try:
                        subprocess.Popen([editor])
                        time.sleep(2)
                        return True
                    except FileNotFoundError:
                        continue
                print("âŒ No suitable text editor found on Linux")
                return False
                
        except Exception as e:
            print(f"âŒ Error launching text editor: {e}")
            return False
    
    def type_text_safely(self, text, delay=0.00005):
        """Type text with character-by-character delay for ultra-fast typing"""
        # Use very fast typing with minimal delay between characters
        for char in text:
            pyautogui.write(char)
            time.sleep(delay)  # Ultra-fast typing
    
    def save_document_macos(self, filename):
        """Save document specifically for macOS TextEdit with improved reliability"""
        try:
            # Use Cmd+S to open save dialog with .hold()
            with pyautogui.hold(['command']):
                time.sleep(0.1)
                pyautogui.press('s')
            time.sleep(2)  # Wait for save dialog
            
            # Clear any existing text in the save dialog with .hold()
            with pyautogui.hold(['command']):
                time.sleep(0.1)
                pyautogui.press('a')
            time.sleep(0.5)
            
            # Type the full file path including directory
            file_path = str(self.project_dir / filename)
            print(f"ğŸ’¾ Saving to: {file_path}")
            
            # Type the path character by character for reliability - very fast
            for char in file_path:
                pyautogui.write(char)
                time.sleep(0.0001)  # Ultra-fast path typing
            
            time.sleep(1)  # Wait after typing path
            
            # Press Enter to confirm save
            pyautogui.press('enter')
            time.sleep(2)  # Wait for save to complete
            
            # Handle potential save dialog confirmations (overwrite existing files)
            try:
                pyautogui.press('enter')  # Confirm overwrite if needed
                time.sleep(1)
            except:
                pass
            
            # Additional check for any remaining dialogs
            try:
                pyautogui.press('enter')
                time.sleep(0.5)
            except:
                pass
            
            return True
        except Exception as e:
            print(f"âŒ Error saving document: {e}")
            return False
    
    def save_document_windows(self, filename):
        """Save document specifically for Windows Notepad"""
        try:
            # Use Ctrl+S to open save dialog
            pyautogui.hotkey('ctrl', 's')
            time.sleep(2)  # Wait for save dialog
            
            # Clear any existing text in the save dialog
            pyautogui.hotkey('ctrl', 'a')  # Select all text
            time.sleep(0.5)
            
            # Type the full file path including directory
            file_path = str(self.project_dir / filename)
            print(f"ğŸ’¾ Saving to: {file_path}")
            
            # Type the path character by character for reliability - very fast
            for char in file_path:
                pyautogui.write(char)
                time.sleep(0.001)  # Ultra-fast path typing
            
            time.sleep(1)  # Wait after typing path
            
            # Press Enter to confirm save
            pyautogui.press('enter')
            time.sleep(2)  # Wait for save to complete
            
            # Handle potential save dialog confirmations (overwrite existing files)
            try:
                pyautogui.press('enter')  # Confirm overwrite if needed
                time.sleep(1)
            except:
                pass
            
            return True
        except Exception as e:
            print(f"âŒ Error saving document: {e}")
            return False
    
    def save_document(self, filename):
        """Save the current document with platform-specific shortcuts"""
        if self.os_type == "Darwin":  # macOS
            return self.save_document_macos(filename)
        elif self.os_type == "Windows":  # Windows
            return self.save_document_windows(filename)
        else:  # Linux
            try:
                # Use Ctrl+S for Linux text editors
                pyautogui.hotkey('ctrl', 's')
                time.sleep(1)  # Wait for save dialog
                
                # Type the full file path including directory
                file_path = str(self.project_dir / filename)
                pyautogui.write(file_path)
                time.sleep(0.5)
                
                # Press Enter to confirm save
                pyautogui.press('enter')
                time.sleep(1)
                
                # Handle potential save dialog confirmations (overwrite existing files)
                try:
                    pyautogui.press('enter')  # Confirm overwrite if needed
                    time.sleep(0.5)
                except:
                    pass
                
                return True
            except Exception as e:
                print(f"âŒ Error saving document: {e}")
                return False
    
    def close_text_editor(self):
        """Close text editor application safely"""
        try:
            if self.os_type == "Darwin":  # macOS
                # Use Cmd+W to close window with .hold()
                with pyautogui.hold(['command']):
                    time.sleep(0.1)
                    pyautogui.press('w')
                time.sleep(1)
                # Handle save prompt by selecting "Don't Save"
                try:
                    pyautogui.press('tab')  # Navigate to "Don't Save" button
                    pyautogui.press('tab')
                    pyautogui.press('enter')
                except:
                    pass
            elif self.os_type == "Windows":  # Windows
                pyautogui.hotkey('alt', 'f4')  # Alt+F4 to close
                time.sleep(1)
                # Handle save prompt by selecting "Don't Save"
                try:
                    pyautogui.press('n')  # Press 'N' for "No" (Don't Save)
                    time.sleep(0.5)
                except:
                    pass
            else:  # Linux
                pyautogui.hotkey('alt', 'f4')  # Alt+F4 to close
            
            time.sleep(1)
        except Exception as e:
            print(f"âŒ Error closing text editor: {e}")
    
    def process_single_post(self, post):
        """Process a single post through the complete automation workflow"""
        print(f"ğŸ“ Processing Post {post['id']}: {post['title'][:50]}...")
        
        # Launch text editor for this post
        if not self.launch_text_editor():
            print(f"âŒ Failed to launch text editor for post {post['id']}")
            return False
        
        try:
            # Format the post content as a blog post
            content = self.format_post_content(post)
            
            # Type the content with ultra-fast typing
            print(f"âŒ¨ï¸  Typing content for post {post['id']}...")
            self.type_text_safely(content)
            
            # Save the document with post ID in filename
            filename = f"post {post['id']}.txt"
            print(f"ğŸ’¾ Saving as {filename}...")
            
            if self.save_document(filename):
                print(f"âœ… Successfully saved {filename}")
                
                # Close text editor to prepare for next post
                self.close_text_editor()
                return True
            else:
                print(f"âŒ Failed to save {filename}")
                self.close_text_editor()
                return False
                
        except Exception as e:
            print(f"âŒ Error processing post {post['id']}: {e}")
            self.close_text_editor()
            return False
    
    def run_automation(self):
        """Main automation workflow that processes all posts"""
        print("ğŸš€ Starting TJM Desktop Automation Bot...")
        print("=" * 60)
        
        # Display OS-specific information
        if self.os_type == "Darwin":
            print("ğŸ Using TextEdit on macOS")
            print("ğŸ’¡ Will use Cmd+S with .hold() method for save dialog")
            print("âš¡ Ultra-fast typing enabled")
        elif self.os_type == "Windows":
            print("ğŸªŸ Using Notepad on Windows")
            print("ğŸ’¡ Will use Ctrl+S to open save dialog")
            print("âš¡ Ultra-fast typing enabled")
        elif self.os_type == "Linux":
            print("ğŸ§ Using available text editor on Linux")
            print("ğŸ’¡ Will use Ctrl+S to open save dialog")
            print("âš¡ Ultra-fast typing enabled")
        
        # Fetch posts from JSONPlaceholder API
        print("ğŸŒ Fetching posts from JSONPlaceholder API...")
        posts = self.fetch_posts(10)
        
        if not posts:
            print("âŒ No posts retrieved. Exiting.")
            return
        
        print(f"ğŸ“‹ Retrieved {len(posts)} posts")
        print("=" * 60)
        
        # Process each post in sequence
        successful_posts = 0
        failed_posts = 0
        
        for i, post in enumerate(posts, 1):
            print(f"\n[{i}/10] Processing post {post['id']}...")
            
            if self.process_single_post(post):
                successful_posts += 1
            else:
                failed_posts += 1
            
            # Small delay between posts to prevent system overload
            time.sleep(1)  # Reduced delay for faster processing
        
        # Display final summary
        print("\n" + "=" * 60)
        print("ğŸ‰ AUTOMATION COMPLETE")
        print(f"âœ… Successful: {successful_posts} posts")
        print(f"âŒ Failed: {failed_posts} posts")
        print(f"ğŸ“ Files saved to: {self.project_dir}")
        
        # List all created files
        if successful_posts > 0:
            print("\nğŸ“„ Created files:")
            for file in sorted(self.project_dir.glob("post *.txt")):
                print(f"  - {file.name}")

def main():
    """Main function with comprehensive error handling and safety features"""
    try:
        # Display safety information and OS detection
        os_type = platform.system()
        print("ğŸ¤– TJM Desktop Automation Bot Starting...")
        print("âš ï¸  IMPORTANT: Move your mouse to the top-left corner to stop the bot at any time")
        
        if os_type == "Darwin":
            print("ğŸ macOS detected - Using TextEdit")
            print("ğŸ’¡ Note: TextEdit will be set to plain text mode automatically")
            print("ğŸ’¾ Save dialog will be opened with Cmd+S using .hold() method")
            print("âš¡ Ultra-fast typing mode enabled")
        elif os_type == "Windows":
            print("ğŸªŸ Windows detected - Using Notepad")
            print("ğŸ’¾ Save dialog will be opened with Ctrl+S")
            print("âš¡ Ultra-fast typing mode enabled")
        elif os_type == "Linux":
            print("ğŸ§ Linux detected - Will try to find suitable text editor")
            print("ğŸ’¾ Save dialog will be opened with Ctrl+S")
            print("âš¡ Ultra-fast typing mode enabled")
        
        print("â° Starting in 3 seconds...")
        
        # Countdown to give user time to prepare (reduced for speed)
        for i in range(3, 0, -1):
            print(f"{i}...")
            time.sleep(1)
        
        # Create and run the automation bot
        bot = DesktopDataEntryBot()
        bot.run_automation()
        
    except KeyboardInterrupt:
        print("\nâ¹ï¸  Bot stopped by user")
    except Exception as e:
        print(f"ğŸ’¥ Unexpected error: {e}")
    finally:
        print("ğŸ Bot terminated")

if __name__ == "__main__":
    main() 